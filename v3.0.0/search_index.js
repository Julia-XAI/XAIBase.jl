var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"AbstractXAIMethod","category":"page"},{"location":"api/#XAIBase.AbstractXAIMethod","page":"API Reference","title":"XAIBase.AbstractXAIMethod","text":"Abstract super type of all XAI methods.\n\nIt is expected that all XAI methods are callable types that return an Explanation:\n\n(method::AbstractXAIMethod)(input, output_selector::AbstractOutputSelector)\n\nIf this function is implemented, XAIBase will provide the analyze functionality and heatmap functionality by loading either VisionHeatmaps.jl or TextHeatmaps.jl.\n\n\n\n\n\n","category":"type"},{"location":"api/#Computing-explanations","page":"API Reference","title":"Computing explanations","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Most methods in the Julia-XAI ecosystem work by calling analyze on an input and an analyzer:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"analyze","category":"page"},{"location":"api/#XAIBase.analyze","page":"API Reference","title":"XAIBase.analyze","text":"analyze(input, method)\nanalyze(input, method, output_selection)\n\nApply the analyzer method for the given input, returning an Explanation. If output_selection is specified, the explanation will be calculated for that output. Otherwise, the output with the highest activation is automatically chosen.\n\nSee also Explanation.\n\nKeyword arguments\n\nadd_batch_dim: add batch dimension to the input without allocating. Default is false.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"The return type of analyze is an Explanation:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Explanation","category":"page"},{"location":"api/#XAIBase.Explanation","page":"API Reference","title":"XAIBase.Explanation","text":"Explanation(val, output, output_selection, analyzer, heatmap, extras)\n\nReturn type of analyzers when calling analyze.\n\nFields\n\nval: numerical output of the analyzer, e.g. an attribution or gradient\noutput: model output for the given analyzer input\noutput_selection: index of the output used for the explanation\nanalyzer: symbol corresponding the used analyzer, e.g. :Gradient or :LRP\nheatmap: symbol indicating a preset heatmapping style,   e.g. :attribution, :sensitivity or :cam\nextras: optional named tuple that can be used by analyzers   to return additional information.\n\n\n\n\n\n","category":"type"},{"location":"api/#Feature-selection","page":"API Reference","title":"Feature selection","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"AbstractFeatureSelector\nIndexedFeatures\nTopNFeatures","category":"page"},{"location":"api/#XAIBase.AbstractFeatureSelector","page":"API Reference","title":"XAIBase.AbstractFeatureSelector","text":"Abstract super type of all feature selectors in XAIBase.\n\nFeature selectors are expected to be callable and to return a vector of CartesianIndices for each selected feature.\n\nNote\n\nThe XAIBase interface currently assumes that features have either 2 or 4 dimensions ((features, batchsize) or (width, height, features, batchsize)).\n\nIt also assumes that the batch dimension is the last dimension of the feature.\n\n\n\n\n\n","category":"type"},{"location":"api/#XAIBase.IndexedFeatures","page":"API Reference","title":"XAIBase.IndexedFeatures","text":"IndexedFeatures(indices...)\n\nSelect features by indices.\n\nFor outputs of convolutional layers, the index refers to a feature dimension.\n\nSee also See also TopNFeatures.\n\nNote\n\nThe XAIBase interface currently assumes that features have either 2 or 4 dimensions ((features, batchsize) or (width, height, features, batchsize)).\n\nIt also assumes that the batch dimension is the last dimension of the feature.\n\nExample\n\njulia> feature_selector = IndexedFeatures(2, 3)\n IndexedFeatures(2, 3)\n\njulia> feature = rand(3, 3, 3, 2);\n\njulia> feature_selector(feature)\n2-element Vector{Vector{CartesianIndices{4, NTuple{4, UnitRange{Int64}}}}}:\n [CartesianIndices((1:3, 1:3, 2:2, 1:1)), CartesianIndices((1:3, 1:3, 2:2, 2:2))]\n [CartesianIndices((1:3, 1:3, 3:3, 1:1)), CartesianIndices((1:3, 1:3, 3:3, 2:2))]\n\njulia> feature = rand(3, 2);\n\njulia> feature_selector(feature)\n 1-element Vector{Vector{CartesianIndices{2, Tuple{UnitRange{Int64}, UnitRange{Int64}}}}}:\n  [CartesianIndices((2:2, 1:1)), CartesianIndices((2:2, 2:2))]\n\n\n\n\n\n","category":"type"},{"location":"api/#XAIBase.TopNFeatures","page":"API Reference","title":"XAIBase.TopNFeatures","text":"TopNFeatures(n)\n\nSelect top-n features.\n\nFor outputs of convolutional layers, the relevance is summed across height and width channels for each feature.\n\nSee also IndexedFeatures.\n\nNote\n\nThe XAIBase interface currently assumes that features have either 2 or 4 dimensions ((features, batchsize) or (width, height, features, batchsize)).\n\nIt also assumes that the batch dimension is the last dimension of the feature.\n\nExample\n\njulia> feature_selector = TopNFeatures(2)\n TopNFeatures(2)\n\njulia> feature = rand(3, 2)\n3×2 Matrix{Float64}:\n 0.265312  0.953689\n 0.674377  0.172154\n 0.649722  0.570809\n\njulia> feature_selector(feature)\n2-element Vector{Vector{CartesianIndices{2, Tuple{UnitRange{Int64}, UnitRange{Int64}}}}}:\n [CartesianIndices((2:2, 1:1)), CartesianIndices((1:1, 2:2))]\n [CartesianIndices((3:3, 1:1)), CartesianIndices((3:3, 2:2))]\n\njulia> feature = rand(3, 3, 3, 2);\n\njulia> feature_selector(feature)\n2-element Vector{Vector{CartesianIndices{4, NTuple{4, UnitRange{Int64}}}}}:\n [CartesianIndices((1:3, 1:3, 2:2, 1:1)), CartesianIndices((1:3, 1:3, 1:1, 2:2))]\n [CartesianIndices((1:3, 1:3, 1:1, 1:1)), CartesianIndices((1:3, 1:3, 3:3, 2:2))]\n\n\n\n\n\n","category":"type"},{"location":"api/#Output-selection","page":"API Reference","title":"Output selection","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"AbstractOutputSelector\nMaxActivationSelector\nIndexSelector","category":"page"},{"location":"api/#XAIBase.AbstractOutputSelector","page":"API Reference","title":"XAIBase.AbstractOutputSelector","text":"Abstract super type of all output selectors in XAIBase.\n\nOutput selectors are expected to be callable and to return a vector of CartesianIndex of the selected outputs.\n\nNote\n\nXAIBase assumes that the batch dimension is the last dimension of the output.\n\n\n\n\n\n","category":"type"},{"location":"api/#XAIBase.MaxActivationSelector","page":"API Reference","title":"XAIBase.MaxActivationSelector","text":"MaxActivationSelector()\n\nOutput selector that picks the output with the highest activation.\n\nNote\n\nXAIBase assumes that the batch dimension is the last dimension of the output.\n\nExample\n\njulia> output = rand(3, 3)\n3×3 Matrix{Float64}:\n 0.411871  0.313366  0.13402\n 0.885562  0.136938  0.465622\n 0.498235  0.627209  0.298911\n\njulia> output_selector = MaxActivationSelector()\n MaxActivationSelector()\n\njulia> output_selector(output)\n 3-element Vector{CartesianIndex{2}}:\n  CartesianIndex(2, 1)\n  CartesianIndex(3, 2)\n  CartesianIndex(2, 3)\n\n\n\n\n\n","category":"type"},{"location":"api/#XAIBase.IndexSelector","page":"API Reference","title":"XAIBase.IndexSelector","text":"IndexSelector(index)\n\nOutput selector that picks the output at the given index.\n\nNote\n\nXAIBase assumes that the batch dimension is the last dimension of the output.\n\nExample\n\njulia> output = rand(3, 3)\n3×3 Matrix{Float64}:\n 0.411871  0.313366  0.13402\n 0.885562  0.136938  0.465622\n 0.498235  0.627209  0.298911\n\njulia> output_selector = IndexSelector(1)\n IndexSelector{Int64}(1)\n\njulia> output_selector(output)\n 3-element Vector{CartesianIndex{2}}:\n  CartesianIndex(1, 1)\n  CartesianIndex(1, 2)\n  CartesianIndex(1, 3)\n\n\n\n\n\n","category":"type"},{"location":"api/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"examples/#examples","page":"Example Implementations","title":"Example Implementations","text":"","category":"section"},{"location":"examples/","page":"Example Implementations","title":"Example Implementations","text":"The following examples demonstrate the implementation of XAI methods using the XAIBase.jl interface. To evaluate our methods, we load a small, pre-trained LeNet5 model and the MNIST dataset:","category":"page"},{"location":"examples/","page":"Example Implementations","title":"Example Implementations","text":"using Flux\nusing BSON\n\nmodel = BSON.load(\"model.bson\", @__MODULE__)[:model] # load pre-trained LeNet-5 model","category":"page"},{"location":"examples/","page":"Example Implementations","title":"Example Implementations","text":"using MLDatasets\nusing ImageCore, ImageIO, ImageShow\n\nindex = 10\nx, y = MNIST(Float32, :test)[10]\n\n# By convention in Flux.jl, the input needs to be resized to WHCN format\n# by adding a color channel and batch dimensions.\ninput = reshape(x, 28, 28, 1, :);\n\nconvert2image(MNIST, x)","category":"page"},{"location":"examples/#Example-1:-Random-explanation","page":"Example Implementations","title":"Example 1: Random explanation","text":"","category":"section"},{"location":"examples/","page":"Example Implementations","title":"Example Implementations","text":"To get started, we implement a nonsensical method that returns a random explanation in the shape of the input.","category":"page"},{"location":"examples/","page":"Example Implementations","title":"Example Implementations","text":"using XAIBase\n\nstruct RandomAnalyzer{M} <: AbstractXAIMethod \n    model::M    \nend\n\nfunction (method::RandomAnalyzer)(input, output_selector::AbstractOutputSelector)\n    output = method.model(input)\n    output_selection = output_selector(output)\n\n    val = rand(size(input)...)\n    return Explanation(val, output, output_selection, :RandomAnalyzer, :sensitivity, nothing)\nend","category":"page"},{"location":"examples/","page":"Example Implementations","title":"Example Implementations","text":"We can directly use XAIBase's analyze function  to compute the random explanation:","category":"page"},{"location":"examples/","page":"Example Implementations","title":"Example Implementations","text":"analyzer = RandomAnalyzer(model)\nexpl = analyze(input, analyzer)","category":"page"},{"location":"examples/","page":"Example Implementations","title":"Example Implementations","text":"Using either VisionHeatmaps.jl or TextHeatmaps.jl, which provide package extensions on XAIBase's Explanation type, we can visualize the explanations:","category":"page"},{"location":"examples/","page":"Example Implementations","title":"Example Implementations","text":"using VisionHeatmaps # load heatmapping functionality\n\nheatmap(expl.val)","category":"page"},{"location":"examples/","page":"Example Implementations","title":"Example Implementations","text":"As expected, the explanation is just noise.","category":"page"},{"location":"examples/#Example-2:-Input-sensitivity","page":"Example Implementations","title":"Example 2: Input sensitivity","text":"","category":"section"},{"location":"examples/","page":"Example Implementations","title":"Example Implementations","text":"In this second example, we naively reimplement the Gradient analyzer from ExplainableAI.jl.","category":"page"},{"location":"examples/","page":"Example Implementations","title":"Example Implementations","text":"using XAIBase\nusing Zygote: gradient\n\nstruct MyGradient{M} <: AbstractXAIMethod \n    model::M    \nend\n\nfunction (method::MyGradient)(input, output_selector::AbstractOutputSelector)\n    output = method.model(input)\n    output_selection = output_selector(output)\n\n    grad = gradient((x) -> only(method.model(x)[output_selection]), input)\n    val = only(grad)\n    return Explanation(val, output, output_selection, :MyGradient, :sensitivity, nothing)\nend","category":"page"},{"location":"examples/","page":"Example Implementations","title":"Example Implementations","text":"note: Note\nExplainableAI.jl implements the Gradient analyzer in a more efficient way  that works with batched inputs and only requires a single forward  and backward pass through the model.","category":"page"},{"location":"examples/","page":"Example Implementations","title":"Example Implementations","text":"Once again, we can directly use XAIBase's analyze and VisionHeatmaps' heatmap functions","category":"page"},{"location":"examples/","page":"Example Implementations","title":"Example Implementations","text":"using VisionHeatmaps \n\nanalyzer = MyGradient(model)\nexpl = analyze(input, analyzer)\nheatmap(expl.val)","category":"page"},{"location":"examples/","page":"Example Implementations","title":"Example Implementations","text":"heatmap(expl.val, colorscheme=:twilight, reduce=:norm, rangescale=:centered)","category":"page"},{"location":"examples/","page":"Example Implementations","title":"Example Implementations","text":"and make use of all the features provided by the Julia-XAI ecosystem.","category":"page"},{"location":"examples/","page":"Example Implementations","title":"Example Implementations","text":"note: Note\nFor an introduction to the Julia-XAI ecosystem,  please refer to the Getting started guide.","category":"page"},{"location":"#docs-interface","page":"XAIBase Interface","title":"Interface description","text":"","category":"section"},{"location":"","page":"XAIBase Interface","title":"XAIBase Interface","text":"XAIBase.jl is a light-weight dependency that defines the interface of XAI methods  in the Julia-XAI ecosystem.","category":"page"},{"location":"","page":"XAIBase Interface","title":"XAIBase Interface","text":"Building on top of XAIBase  (or providing an interface via package extensions) makes your package compatible with the Julia-XAI ecosystem, allowing you to automatically compute heatmaps for vision and language models using VisionHeatmaps.jl and TextHeatmaps.jl.","category":"page"},{"location":"","page":"XAIBase Interface","title":"XAIBase Interface","text":"This only requires you to fulfill the following two requirements:","category":"page"},{"location":"","page":"XAIBase Interface","title":"XAIBase Interface","text":"An XAI method has to be a subtype of AbstractXAIMethod\nAn XAI method has to implement the following method: ","category":"page"},{"location":"","page":"XAIBase Interface","title":"XAIBase Interface","text":"(method::MyMethod)(input, output_selector::AbstractOutputSelector)","category":"page"},{"location":"","page":"XAIBase Interface","title":"XAIBase Interface","text":"The method has to return an Explanation\nThe input is expected to have a batch dimensions as its last dimension\nWhen applied to a batch, the method returns a single Explanation,  which contains the batched output in the val field.\nAbstractOutputSelectors are predefined callable structs  that select a single scalar value from a model's output,  e.g. the maximally activated output of a classifier using MaxActivationSelector or a specific output using IndexSelector.","category":"page"},{"location":"","page":"XAIBase Interface","title":"XAIBase Interface","text":"Refer to the Explanation documentation for a description of the expected fields. For more information, take a look at src/XAIBase.jl.","category":"page"},{"location":"#Implementation-template","page":"XAIBase Interface","title":"Implementation template","text":"","category":"section"},{"location":"","page":"XAIBase Interface","title":"XAIBase Interface","text":"Julia-XAI methods will usually follow the following template:","category":"page"},{"location":"","page":"XAIBase Interface","title":"XAIBase Interface","text":"struct MyMethod{M} <: AbstractXAIMethod \n    model::M    \nend\n\nfunction (method::MyMethod)(input, output_selector::AbstractOutputSelector)\n    output = method.model(input)\n    output_selection = output_selector(output)\n\n    val = ...         # your method's implementation\n    extras = nothing  # optionally add additional information using a named tuple\n    return Explanation(val, output, output_selection, :MyMethod, :attribution, extras)\nend","category":"page"},{"location":"","page":"XAIBase Interface","title":"XAIBase Interface","text":"Refer to the example implementations for more information.","category":"page"}]
}
